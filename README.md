This project is a simple Roguelike written in Ruby and run in a terminal through the Ruby standard Curses library.

Structure of the program:
All game-related classes are isolated from the Curses implementation; the engine can receive a set of known symbols as input, and manages a group of game objects who respond to engine events. These game objects have display-agnostic UI views which describe how they are presented, and these view objects are collected in a tree-like view heirarchy, managed by the engine. This view heirarchy is then passed to the boundary between the game layer and the Curses layer, where it gets translated into a Curses view heirarchy that describes exactly how the objects should be drawn to the terminal. Flow occurs as follows: The user creates hardware input in Curses. This passes through a thin IO wrapper and is fed into the Curses view heirarchy for a response. If the command is purely cosmetic (changing pagination, scrolling text, etc), the views are updated and the response sent back through the IO wrapper to be drawn. If the command is functional, the views return the specific event symbol/target and pass it on to the engine. The engine then fires the event, waits for its game objects to finish updating, then returns the display-agnostic view heirarchy. This updates the Curses views, which then get passed to the IO wrapper and drawn to the screen. The process looks like this:

  (                  )                   |              |          [[[ Curses Views ]]]   <---Sync from engine---|                  |                             ---->( Game Objects ) 
 (                    )  --HW Input----> |              |               ^ v                                      |                  | --Input symbol-> [ Engine ]--->( Game Objects )
(      Curses          )                 | [IO Wrapper] | --Input --> [Controller] --> Functional response ----->| [Engine Wrapper] |                    |        ---->( Game Objects )
 (                    ) <--HW Output---  |              |                            v Cosmetic response         |                  |                    v       
  (                  )                   |              | <-Output--- [Renderer]  <------------------------------|                  | <-------------- [View heirarchy ]
